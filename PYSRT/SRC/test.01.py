#!/usr/bin/env python
#-*- coding: utf-8 -*-

import traceback
import argparse
import sys
import os
import chardet
import re

from collections import namedtuple
try:
    sys.path.append('.')
    from utils import time as srtTime
    from utils import utils as myUtils
except ImportError:
    SRCPATH=os.path.dirname(os.path.abspath(__file__))
    sys.path.append(SRCPATH)
    import utils.time as srtTime
    import utils.utils as myUtils

def convert_utf8(str, encode='utf-8'):
    ret = chardet.detect(str)
    chset = ret['encoding']  ##.lower()

    retUTF8 = str
    if chset == 'ascii' or chset == None or chset.lower() == 'utf-8':
        return chset, retUTF8

    try:
        # retUTF8 = str.decode(chset).encode('utf8')
        # retUTF8 = str.decode('euc-kr').encode('utf8')
        retUTF8 = unicode(str,'euc-kr').encode(encode)
    except Exception as e:
        # print ("ERROR::01::{0}".format(traceback.format_exc()))
        try:
            if chset == None or chset == "TIS-620":
                retUTF8 = unicode(str,'cp949').encode(encode)
            else:
                retUTF8 = unicode(str,chset).encode(encode)
        except Exception as e:
            # print ("ERROR::02::{0} :: {1}".format(traceback.format_exc(),retUTF8))
            retUTF8 = str

    # print ("ORG [{2}]===>> chset [{0}] ===> UTF8 [{1}]".format(chset, retUTF8, str))
    return chset, retUTF8

def convert_encode(str, encode='utf-8'):
    ret = chardet.detect(str)
    chset = ret['encoding']  ##.lower()

    retUTF8 = str
    if chset == 'ascii' or chset == None or chset.lower() == encode.lower():
        return chset, retUTF8

    try:
        retUTF8 = str.decode(chset).encode(encode)
    except Exception as e:
        # print ("ERROR::01::{0}".format(traceback.format_exc()))
        try:
            retUTF8 = unicode(str,'euc-kr').encode(encode)
        except:
            # print ("ERROR::02-01::{0}".format(traceback.format_exc()))
            try:
                if chset == "TIS-620":
                    retUTF8 = unicode(str,'cp949').encode(encode)
            except Exception as e:
                # print ("ERROR::02-02::{0} :: {1}".format(traceback.format_exc(),retUTF8))
                retUTF8 = str

    # print ("ORG [{2}]===>> chset [{0}] ===> UTF8 [{1}]".format(chset, retUTF8, str))
    return chset, retUTF8


'''
>>> fname='/Users/eastwood/Downloads/__Español__/_Peliculas/A.Simple.Favor.2018.PROPER.1080p.BluRay.H264.AAC-RARBG.smi'
>>> a=os.path.dirname(os.path.realpath(fname))
>>> b=os.path.basename(fname)
>>> c=os.path.splitext(b)
>>> a
'/Users/eastwood/Downloads/__Espan\xcc\x83ol__/_Peliculas'
>>> b
'A.Simple.Favor.2018.PROPER.1080p.BluRay.H264.AAC-RARBG.smi'
>>> c
('A.Simple.Favor.2018.PROPER.1080p.BluRay.H264.AAC-RARBG', '.smi')
>>> c[0], c[1]
('A.Simple.Favor.2018.PROPER.1080p.BluRay.H264.AAC-RARBG', '.smi')
>>>
'''
def getOutFileName(fname, type='srt'):
    workPath = os.path.dirname(os.path.realpath(fname))
    workName = os.path.basename(fname)
    workList = os.path.splitext(workName)

    # print ("getOutFileName :: {0}/{1}.{2}".format(workPath, workList[0], type))
    return "{0}/{1}.{2}".format(workPath, workList[0], type)

class SyncParser(argparse.ArgumentParser):
    """A parser that displays argparse's help message by default."""

    def error(self, message):
        self.print_help()
        sys.exit(1)

class Smi2Srt(object):
    '''

    # - 통합자막의 경우
    # <!--  Generated by KMPlayer
    # .KRCC
    # .ENCC
    # -->
<SAMI>
<HEAD>
<TITLE>Uzys SMI Merge Tool</TITLE>
<STYLE TYPE="text/css">
<!--
P { margin-left:2pt; margin-right:2pt; margin-bottom:1pt;
font-size:20pt; text-align:center; font-weight:bold;
color:white; }
.ENCC { Name:English; lang:en-US; SAMIType:CC; }
.KRCC { Name:한국어; lang:ko-KR; SAMIType:CC; }
-->
</STYLE>
</HEAD>
<BODY>
<SYNC Start=7113063><P Class=KRCC>
&nbsp;

<SYNC Start=153617><P Class=ENCC>
</BODY></SAMI>
    '''

    DEFAULT_START_AT = "same as input; original .srt file will be copied to ORIGINAL_SRT_NAME_orig.srt"

    def __init__(self, smifname=None):
        self.SRT_DATA = []
        self.secondPos = 0
        self.SMI_HEADER = []
        self.SMI_LANG = []
        self.srtfname = ''
        self.smifname = smifname

        self.encode = 'utf8'
        self.encodeYN = False

        self.parser = SyncParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
        self.parser.add_argument("-c", "--convert_to",
                                 help="convert to .srt subtitles file",
                                 metavar='utf-8')

        self.parser.add_argument("-o", "--output",
                                 help="the output .srt subtitles file",
                                 default=self.DEFAULT_START_AT)

        self.parser.add_argument("input_file", type=str,
                                 help="the .srt subtitles file")

    def check_args(self, args):
        """
        Checks that command-line arguments are valid.

        """

        input_file = args.input_file
        convert_opt = args.convert_to

        if not os.path.isfile(input_file):
            print('{} does not exist'.format(input_file))
            return None
        else:
            if not args.output or args.output == self.DEFAULT_START_AT:
                output_subs = getOutFileName(input_file)
            else:
                output_subs = args.output

        if convert_opt is not None:
            self.encode = convert_opt
            self.encodeYN = True

        # print ("Last => Input : {}, Output:{}".format(input_file, output_subs))

        return input_file, output_subs

    def convert_encoding(self, content):
        if content is None or content == '' or self.encodeYN == False:
            return 'UTF-8', content

        return convert_encode(content, self.encode)


    def setFilename(self, fname):
        self.smifname = fname
        self.srtfname = getOutFileName(fname)

    def get2ndFilename(self):
        fname = self.srtfname
        return fname[:-3] + '2nd.srt'

    def smiParse(self):
        with open(self.smifname) as f_in:
             lines = filter(None, (line.rstrip() for line in f_in))

        idx = 0
        etime = 0
        content = [0, '']        ## stime, content
        contents =[]        ## content-1, ..., content-n

        SW = False
        self.SMI_HEADER = []
        for idx, line in enumerate(lines):
            if line[0:4] == '<!--':
                SW = True
                self.SMI_HEADER.append(line)
                continue

            if line[0:3] == '-->':
                SW = False
                self.SMI_HEADER.append(line)
                continue

            if SW:
                self.SMI_HEADER.append(line)
                if line[0] == '.':
                    self.SMI_LANG.append(line)
                continue

            if '<BODY>' in line:
                break

        idx += 1 ## '<BODY>' skip
        SW = False
        SRT_Line = [0, 0, 0, 0, '', ''] ## Num, cnt, stime, etime, contents, lang

        time00 = ''
        lang = ''
        for idx, line in enumerate(lines[idx:],idx):
            # if line == '</BODY>':
            #     break
            if '</BODY>' in line:   ## 다른 언어의 자막으로 변경되어야 함.
                self.secondPos = len(self.SRT_DATA) if self.secondPos == 0 else self.secondPos
                continue

            if '</SAMI>' in line:
                break;

            if line[0:5] == '<SYNC':
                m = re.search(r'<sync\s+start\s*=\s*(\d+)>(.*)$', line, flags=re.IGNORECASE)
                if not m:
                    raise Exception('Invalid format tag of <Sync start=nnnn> with "%s"' % line)

                time00 = m.group(1)
                if lang != '' and lang[0:14] != m.group(2)[0:14]:
                    self.secondPos = len(self.SRT_DATA) if self.secondPos == 0 else self.secondPos

                lang = m.group(2)

                if line.find('&nbsp;') >= 0:
                    etime = int(time00)
                    SW = True
                else:
                    content[0] = int(time00)
            else:
                if line.find('&nbsp;') >= 0:
                    etime = int(time00)
                    SW = True
                    line = line.replace('&nbsp;', '')

                ## &nbsp;<br>&nbsp;<br><i>짦은 몇 년 새에</i> <== <br><br><i>짦은 몇 년 새에
                ## &nbsp;                                  <== '' ==> <SYNC Start=324275><P Class=KRCC>&nbsp;
                ## <i>그 땅의 모든 곳에서</i>                  <== <i>그 땅의 모든 곳에서</i>
                ## 위 3가지 경우에 대한 처리
                if line != '':
                    content[1] = content[1] + line
                    contents.append(content)
                    content = [0 , '']

            if SW:
                cnt = len(contents)
                for cln in contents:
                    # timeLine = "{} --> {}".format(srtTime.ms_to_str(cln[0], True), srtTime.ms_to_str(etime, True))
                    chdet, UTF8DATA = convert_utf8(cln[1], self.encode)
                    # print ("{0:>4d}.Line [{1}] ==> {4} TimeLine :: {2}  ==> {3}".format(idx, line, timeLine, UTF8DATA, etime - cln[0]))

                    ## Num, cnt, stime, etime, contents, language
                    SRT_Line[0] = idx
                    SRT_Line[1] = cnt
                    SRT_Line[2] = cln[0]
                    SRT_Line[3] = etime
                    SRT_Line[4] = UTF8DATA
                    SRT_Line[5] = lang
                    self.SRT_DATA.append(SRT_Line)
                    SRT_Line = [0, 0, 0, 0, '', '']     ## 이것이 없으면 맨 마지막 자료만 들어감.

                etime = 0
                SW = False
                content = [0 , '']
                del contents[:]

    def srtWrite(self):
        if len(self.SMI_LANG) >= 2:
            self.srtFirstWrite(self.srtfname, self.SRT_DATA[0:self.secondPos])
            print("First Language Writing compleate {0} !!!".format(self.srtfname))
            secFname =  self.get2ndFilename()
            self.srtFirstWrite(secFname, self.SRT_DATA[self.secondPos:])
            print("Second Language Writing compleate {0} !!!".format(secFname))
        else:
            self.srtFirstWrite(self.srtfname, self.SRT_DATA)
            print("Writing compleate {0} !!!".format(self.srtfname))

    def srtFirstWrite(self, fname, SRT_DATA):
        idx = 0
        srtIDX = 0
        # print("output fname = {}".format(fname))
        with open(fname, 'w') as f_out:
            while 1:
                srtln = SRT_DATA[idx]
                # print ("{} ==> {}, {}, {}, {}".format(srtln[0],srtln[1],srtln[2],srtln[3],srtln[4]))
                # idx += 1

                if srtln[1] == 1:  ## 1의 경우
                    srtIDX += 1
                    srtContent = "{0}\n{1} --> {2}\n{3}\n\n".format(srtIDX,
                                                                srtTime.ms_to_str(srtln[2], True),
                                                                srtTime.ms_to_str(srtln[3], True),
                                                                srtln[4])
                    idx += 1

                elif srtln[1] == 2:  ## 2의 경우
                    subData = SRT_DATA[idx:idx + srtln[1]]
                    if subData[1][2] != 0:
                        srtIDX += 1
                        srtContent = "{0}\n{1} --> {2}\n{3}\n\n".format(srtIDX,
                                                                srtTime.ms_to_str(subData[0][2], True),
                                                                srtTime.ms_to_str(subData[1][2] - 10, True),
                                                                # srtTime.ms_to_str(subData[0][3], True),
                                                                subData[0][4])
                        srtIDX += 1
                        srtContent = "{4}\n{0}\n{1} --> {2}\n{3}\n\n".format(srtIDX,
                                                                srtTime.ms_to_str(subData[1][2], True),
                                                                srtTime.ms_to_str(subData[1][3], True),
                                                                subData[1][4],
                                                                srtContent)
                    else:
                        srtIDX += 1
                        srtContent = "{0}\n{1} --> {2}\n{3}\n\n".format(srtIDX,
                                                                srtTime.ms_to_str(subData[0][2], True),
                                                                srtTime.ms_to_str(subData[1][3], True),
                                                                subData[0][4] + subData[1][4])

                    idx += 2

                else:  ## 3개이상의 경우
                    tmpLen = srtln[1]
                    subData = SRT_DATA[idx:idx + srtln[1]]

                    srtContent = ''

                    stime = 0
                    etime = 0
                    contents = ''

    ## sub While start
                    lidx = 0
                    while lidx < tmpLen:
                        ldata = subData[lidx]

                        # print ("{} == {}, {}, {}, {}, {}".format(lidx, ldata[0],ldata[1],ldata[2],ldata[3],ldata[4]))
                        try:
                            nextData = subData[lidx + 1]
                        except:
                            nextData = [0,0,0,0,'']

                        contents = contents + ldata[4]

                        if nextData[2] != 0:        ## 개별적 자료일 경우에 대한 처리
                            stime = ldata[2]
                            etime = nextData[2] - 100
                            srtIDX += 1
                            srtContent = "{4}\n{0}\n{1} --> {2}\n{3}\n\n".format(srtIDX,
                                                                        srtTime.ms_to_str(stime, True),
                                                                        srtTime.ms_to_str(etime, True),
                                                                        contents,
                                                                        srtContent)
                            stime = nextData[2]
                            etime = 0
                            contents = ''
                            lidx += 1
                        else:
                            # 'Yes' if fruit == 'Apple' else 'No'
                            stime = ldata[2] if stime == 0 else stime
                            etime = ldata[3] if etime == 0 else etime
                            if nextData[0] == 0:
                                srtIDX += 1
                                srtContent = "{4}\n{0}\n{1} --> {2}\n{3}\n\n".format(srtIDX,
                                                                        srtTime.ms_to_str(stime, True),
                                                                        srtTime.ms_to_str(etime, True),
                                                                        contents,
                                                                        srtContent)

                            lidx += 1
    ## sub while end

                    idx += tmpLen
                if (srtIDX == 1 and srtContent[0] == '\n'):
                    srtContent = srtContent.replace("<br>", "\n")
                    f_out.write(srtContent[1:])
                else:
                    srtContent = srtContent.replace("<br>", "\n")
                    f_out.write(srtContent)

                # print srtContent

                if idx >= len(SRT_DATA):
                    break;

    def smi2srt(self):
        args = self.parser.parse_args()
        parsed = self.check_args(args)
        if not parsed:
            print('')
            self.parser.error('Bad arguments.')

        self.smifname, self.srtfname = parsed

        # print ("SRC:{}, DEST:{}, Encode:{}".format(self.smifname, self.srtfname, self.encode))

        self.smiParse()
        print("Parsing compleate {0} !!!".format(self.smifname))
        self.srtWrite()

##------------------------------------------------------------ end Class Smi2Srt

def converting_test(fname):
    with open(fname) as f_in:
         lines = filter(None, (line.rstrip() for line in f_in))

    for ln in lines:
        chset, retUTF8 = convert_utf8(ln, self.encode)
        print ("ORG [{2}]===>> chset [{0}] ===> UTF8 [{1}]".format(chset, retUTF8, ln))

if __name__ == '__main__':
    '''
python ./test.01.py -c utf-8 "2 Harry Potter and the Chamber of Secrets (2002)ac3.smi"

$ python ./test.01.py
usage: test.01.py [-h] [-c utf-8] [-o OUTPUT] input_file

positional arguments:
  input_file            the .srt subtitles file

optional arguments:
  -h, --help            show this help message and exit
  -c utf-8, --convert_to utf-8
                        convert to .srt subtitles file (default: None)
  -o OUTPUT, --output OUTPUT
                        the output .srt subtitles file (default: same as
                        input; original .srt file will be copied to
                        ORIGINAL_SRT_NAME_orig.srt)


for i in /opt/PYSRT/Data/smi2/*.smi; do python ./test.01.py "$i"; done
    '''
    # fname = sys.argv[1]
    # converting_test(fname)

    converting = Smi2Srt()
    converting.smi2srt()

    # print ("SMI : {0}\nSRT : {1}".format(converting.smifname, converting.srtfname))
    # print ("SMI_LANG : {0}".format(converting.SMI_LANG))
    # print ("self.secondPos :: {0}".format(converting.secondPos))
    # for l in converting.SRT_DATA:
    #     print ("SRT_DATA : {0}, {1}, {2}, {3}, {4}, {5}".format(l[0],l[1],l[2],l[3],l[4],l[5]))
